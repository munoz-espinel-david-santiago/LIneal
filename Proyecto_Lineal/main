"""
PROYECTO DE ÁLGEBRA LINEAL - IDEA 3: RUTAS ÓPTIMAS EN REDES
============================================================================
Diseño de Rutas Óptimas en Redes de Telecomunicaciones mediante 
Programación Lineal y Álgebra de Matrices

Estudiantes:
- Dubin Andres Soto Parodi
- Juan David Idarraga Porras
- David Santiago Muñoz Espinel

Profesor: Juan Pablo Fernández Gutiérrez
Universidad de Medellín
============================================================================
"""

import numpy as np
from scipy.optimize import linprog
import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd
from itertools import combinations

# ============================================================================
# SECCIÓN 1: DEFINICIÓN DE LA TOPOLOGÍA DE LA RED
# ============================================================================
nodos = ['A', 'B', 'C', 'D', 'E', 'F']
n_nodos = len(nodos)
indice_nodos = {nodo: i for i, nodo in enumerate(nodos)}

# Enlaces con latencias (ms)
enlaces = [
    ('A', 'B', 10),
    ('A', 'C', 15),
    ('B', 'D', 5),
    ('B', 'E', 8),
    ('C', 'D', 12),
    ('D', 'E', 4),
    ('D', 'F', 20),
    ('E', 'F', 10),
]

latencias = {}
for n1, n2, lat in enlaces:
    latencias[(n1, n2)] = lat
    latencias[(n2, n1)] = lat

capacidades = {
    ('A', 'B'): 100,
    ('A', 'C'): 80,
    ('B', 'D'): 50,
    ('B', 'E'): 120,
    ('C', 'D'): 90,
    ('D', 'E'): 110,
    ('D', 'F'): 60,
    ('E', 'F'): 150,
}

origen = 'A'
destino = 'F'
tráfico = 40  # Gbps

# ============================================================================
# SECCIÓN 2: MATRIZ DE COSTOS
# ============================================================================
costos = np.full((n_nodos, n_nodos), np.inf)
for n1, n2, latencia in enlaces:
    i, j = indice_nodos[n1], indice_nodos[n2]
    costos[i, j] = latencia
    costos[j, i] = latencia
np.fill_diagonal(costos, 0)

# ============================================================================
# SECCIÓN 3: VISUALIZACIÓN DE LA RED
# ============================================================================
G = nx.Graph()
G.add_nodes_from(nodos)
for n1, n2, latencia in enlaces:
    G.add_edge(n1, n2, weight=latencia)

pos = nx.spring_layout(G, seed=42, k=2.5, iterations=50)
plt.figure(figsize=(12, 8))
nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=2000, edgecolors='black', linewidths=2)
nx.draw_networkx_edges(G, pos, width=2.5, alpha=0.7)
nx.draw_networkx_labels(G, pos, font_size=16, font_weight='bold')
# Etiquetas de enlaces (latencia + capacidad)
edge_labels = {}
for n1, n2, latencia in enlaces:
    cap = capacidades.get((n1, n2), capacidades.get((n2, n1)))
    edge_labels[(n1, n2)] = f"{latencia}ms\n{cap}Gbps"
nx.draw_networkx_edge_labels(G, pos, edge_labels, font_size=12)
plt.title("Topología de Red\nLatencia (ms) y Capacidad (Gbps)", fontsize=15, fontweight='bold')
plt.axis('off')
plt.tight_layout()
plt.savefig('topologia_red_completa.png', dpi=300, bbox_inches='tight')
plt.close()

# ============================================================================
# SECCIÓN 4: PROBLEMA DE OPTIMIZACIÓN LINEAL
# ============================================================================
aristas = []
for n1, n2, _ in enlaces:
    aristas.append((n1, n2))
    aristas.append((n2, n1))
n_aristas = len(aristas)

# FUNCIÓN OBJETIVO
c = np.zeros(n_aristas)
for idx, (n1, n2) in enumerate(aristas):
    c[idx] = latencias[(n1, n2)]

# RESTRICCIONES DE CONSERVACIÓN DE FLUJO (A_eq)
A_eq = np.zeros((n_nodos, n_aristas))
for nodo_idx, nodo in enumerate(nodos):
    for arista_idx, (n1, n2) in enumerate(aristas):
        if nodo == n1:  # Salida
            A_eq[nodo_idx, arista_idx] += 1
        if nodo == n2:  # Entrada
            A_eq[nodo_idx, arista_idx] -= 1
b_eq = np.zeros(n_nodos)
b_eq[indice_nodos[origen]] = tráfico
b_eq[indice_nodos[destino]] = -tráfico

# RESTRICCIONES DE CAPACIDAD
A_ub = []
b_ub = []
for arista_idx, (n1, n2) in enumerate(aristas):
    restriccion = np.zeros(n_aristas)
    restriccion[arista_idx] = 1
    if (n1, n2) in capacidades:
        cap = capacidades[(n1, n2)]
    elif (n2, n1) in capacidades:
        cap = capacidades[(n2, n1)]
    else:
        cap = np.inf
    if cap != np.inf:
        A_ub.append(restriccion)
        b_ub.append(cap)
A_ub = np.array(A_ub)
b_ub = np.array(b_ub)
bounds = [(0, None) for _ in range(n_aristas)]

# ============================================================================
# SECCIÓN 5: RESOLVER CON LINPROG
# ============================================================================
resultado = linprog(
    c=c,
    A_ub=A_ub,
    b_ub=b_ub,
    A_eq=A_eq,
    b_eq=b_eq,
    bounds=bounds,
    method='highs'
)

if resultado.success:
    flujo_optimo = resultado.x
    rutas_activas = []
    for idx, flujo in enumerate(flujo_optimo):
        if flujo > 1e-6:
            n1, n2 = aristas[idx]
            rutas_activas.append((n1, n2, flujo))
    # Reconstruir el camino óptimo
    camino = [origen]
    nodo_actual = origen
    while nodo_actual != destino:
        siguiente_encontrado = False
        for n1, n2, flujo in rutas_activas:
            if n1 == nodo_actual and flujo > 0.01:
                camino.append(n2)
                nodo_actual = n2
                siguiente_encontrado = True
                break
        if not siguiente_encontrado:
            break
    print("Camino óptimo:", " → ".join(camino))
    # Desglose latencias
    latencia_camino = 0
    for i in range(len(camino) - 1):
        latencia_camino += latencias[(camino[i], camino[i+1])]
    print("Latencia total:", latencia_camino, "ms")
else:
    print("✗ No se encontró solución óptima")

# ============================================================================
# SECCIÓN 6: ANÁLISIS COMPARATIVO DE RUTAS
# ============================================================================
rutas_alternativas = [
    (['A', 'B', 'E', 'F'], "Óptima (linprog)"),
    (['A', 'B', 'D', 'F'], "Alternativa 1"),
    (['A', 'C', 'D', 'F'], "Alternativa 2"),
    (['A', 'C', 'D', 'E', 'F'], "Alternativa 3"),
    (['A', 'B', 'D', 'E', 'F'], "Alternativa 4"),
]
resultados = []
for ruta, desc in rutas_alternativas:
    lat_total = 0
    cap_min = np.inf
    enlace_cuello = None
    valida = True
    for i in range(len(ruta) - 1):
        n1, n2 = ruta[i], ruta[i+1]
        if (n1, n2) not in latencias:
            valida = False
            break
        lat_total += latencias[(n1, n2)]
        cap = capacidades.get((n1, n2), capacidades.get((n2, n1)))
        if cap < cap_min:
            cap_min = cap
            enlace_cuello = f"{n1}-{n2}"
    if valida:
        cumple = "✓ SÍ" if tráfico <= cap_min else "✗ NO"
        resultados.append({
            'Ruta': ' → '.join(ruta),
            'Descripción': desc,
            'Latencia (ms)': lat_total,
            'Saltos': len(ruta) - 1,
            'Cuello Botella': enlace_cuello,
            'Capacidad Mínima (Gbps)': cap_min,
            'Cumple Capacidad': cumple,
            'Costo (ms·Gbps)': lat_total * tráfico
        })
df = pd.DataFrame(resultados)
print("\n", df.to_string(index=False))
df.to_csv('analisis_rutas.csv', index=False, encoding='utf-8')
